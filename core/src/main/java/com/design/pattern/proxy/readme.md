## Java动态代理

Java动态代理模式是一种常见的代理模式，它在运行时动态地创建一个代理类，该代理类实现了指定的接口并将方法调用委托给指定的对象。通过使用Java动态代理模式，可以在不修改原有代码的情况下，为对象添加额外的功能或控制访问。


1. 基于接口的动态代理

基于接口的动态代理是指代理类和被代理类必须实现同一个接口。Java提供了一个Proxy类和一个InvocationHandler接口来实现基于接口的动态代理。在基于接口的动态代理中，Proxy类会动态创建一个实现指定接口的代理类，代理类中的方法实现则是通过调用InvocationHandler接口的invoke()方法来实现的。

2. 基于类的动态代理

基于类的动态代理是指代理类继承于被代理类，并且代理类能够代理被代理类的所有方法。Java提供了一个cglib库来实现基于类的动态代理。cglib库会动态创建一个继承于被代理类的代理类，并在代理类中重写被代理类的方法，从而实现代理类的功能。

需要注意的是，基于接口的动态代理只能代理实现了接口的类，而基于类的动态代理可以代理没有实现接口的类，但是需要被代理的类不能被final修饰。在实际应用中，基于接口的动态代理更为常用，因为它可以代理多个接口，而且更符合面向接口编程的原则。

### 区别

JDK动态代理和CGLIB动态代理的主要区别在于它们的实现方式和适用范围：

1. 实现方式不同：
   JDK动态代理是基于接口的代理，它要求目标对象必须实现一个或多个接口，利用Java反射机制在运行时动态地生成代理类，并将方法调用分派到代理类的处理器上。因为是基于接口实现的，所以代理类只能代理接口中定义的方法。

CGLIB动态代理是基于继承的代理，它不要求目标对象实现接口，而是通过创建目标类的子类来实现代理。在运行时动态生成代理类的子类，并重写其中的非final方法，将方法调用转发到代理类的处理器上。

2. 适用范围不同：
   由于JDK动态代理是基于接口实现的，所以只能为接口中定义的方法创建代理，而无法为类中的方法创建代理。而CGLIB动态代理是通过继承目标类来实现代理的，所以可以为类中的所有非final方法创建代理。

综上所述，JDK动态代理适用于对接口进行代理的情况，CGLIB动态代理适用于对类进行代理的情况。但由于CGLIB动态代理采用的是继承，所以在生成代理对象时，需要对目标类进行扩展，因此对于final类或final方法，CGLIB动态代理是无法代理的。


### 使用场景

动态代理模式的应用场景比较广泛，以下是一些常见的场景：

1. AOP编程
   动态代理可以很好地实现AOP编程，如事务管理、日志管理、权限控制等。

2. 远程调用
   动态代理可以实现远程方法调用（RMI），例如Java中的RMI机制就是通过动态代理来实现的。

3. 延迟加载
   当一个对象很大或者初始化很慢时，可以使用动态代理模式来实现延迟加载，只有在真正需要使用时才去创建对象。

4. 缓存代理
   缓存代理可以提高程序的性能，在访问一个对象时，如果该对象已经被缓存，则直接返回缓存中的对象，否则就先创建一个对象并缓存起来。

5. 权限控制
   动态代理可以实现权限控制，如在调用某个方法之前检查当前用户是否具有调用该方法的权限。

总之，动态代理可以通过在运行时动态地生成代理类来实现一些功能，从而增强程序的灵活性和可扩展性。

### 实现例子

#### jdk动态代理（基于接口）

#### cglib动态代理（基于类）


## Java静态代理
