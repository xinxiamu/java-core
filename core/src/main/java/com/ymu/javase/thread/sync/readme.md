//对象及变量的并发访问

//类方法内部的局部变量是线程安全的

//类的全局变量是非线程安全的，多个线程访问会出现数据竞争

## synchronized弊端

尽管`synchronized`同步块是Java中实现线程同步的一种有效方式，但它也有一些弊端，其中一些可能导致性能问题和限制：

1. **粒度过大：** 如果使用不当，同步块的粒度可能太大，导致性能问题。如果一个线程在同步块内执行了大量操作，而其他线程需要等待获得锁才能执行，会降低并发性能。

2. **可能引发死锁：** 如果线程在一个同步块内部尝试获得多个锁，可能会引发死锁，其中线程之间相互等待对方释放锁，导致程序永远无法继续执行。

3. **难以调试：** 同步问题是难以调试的，因为它们通常依赖于线程的执行顺序，而线程的执行顺序是难以确定的。

4. **性能开销：** `synchronized` 增加了一些性能开销，因为每个进入同步块的线程都必须获取锁，释放锁，以及竞争锁。这些开销可能在高并发情况下积累。

5. **不足以处理复杂同步需求：** `synchronized` 只提供了基本的同步机制，对于一些复杂的同步需求，可能不够灵活，例如，你无法指定一个超时时间来等待锁，也无法中断等待的线程。

由于这些潜在问题，现代Java编程更倾向于使用`java.util.concurrent`包中的更高级的同步工具，如`ReentrantLock`、`Semaphore`、`CountDownLatch`等，以提供更多的控制和性能优化选项。这些工具可以更精确地满足复杂的同步需求，并允许更细粒度的控制。
